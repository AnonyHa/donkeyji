面向对象的程序，虽然定义了一堆的类对象，但是在最上层的main函数中，仍然是一种过程化的结构，但是此时的过程已经非常简单，无需处理数量巨大的变量，只需简单的处理几个经过一层一层封装的类对象，所以过程比较简单，若稍微复杂，则可以再定义几个函数来处理。每个类里的成员函数的设计其实也是一种过程，但是这些函数过程需要面对的数据仅仅是自己的成员数据，所以并不会复杂。很显然，面向对象容易对功能进行模块化。


所谓的继承，不过提供一种新的对数据操作的函数。


全局变量的作用：不在于其生存时间，而在于它能被多个函数访问。全局变量类似一个单例对象，同一类型的对象不能产生多个。

类的作用：描述了一些属性变量和对这些属性的操作的函数，它可以产生多个对象，每个对象是相互独立的。一个对象的数据是可以被其成员函数共同访问的，但是并不是像全局变量那样，而是通过this指针来实现的。

类似Java，完全面向对象的程序里是无需全局变量和全局函数的，任何需要对数据的操作都可以封装成类，在main函数中的操作只剩下简单的几个类的交互。假如需要用到全局变量时，便可以把该全局变量以及对他操作的多个函数封装到一个类中，这样就避免全局变量的使用，在高一层的代码中，便只需用一个该类的栈变量即可，因为全局变量的作用不在于其生存时间，而在于访问范围。



同一系统：不同的进程及其关系
同一进程：不同的模块及其关系
同一模块：不同的类及其关系


网络游戏进程：
把网络传输单独成一个模块，写成一个类，只负责发包/收包，至于发什么包、收到包后如何处理，由游戏逻辑模块负责。
消息处理单独成一个模块，写成一个类，把所有用到的消息类型及其处理方法放在一起，便于扩展。
场景对象放进mapmgr中，实现具体游戏逻辑。

客户端设计：
class netstream
class cmdmgr
class mapmgr
class game: mapmgr, cmdmgr, netstream

服务端设计：
class nethost
class cmdmgr
class mapmgr
class game: mapmgr, cmdmgr, netstream
